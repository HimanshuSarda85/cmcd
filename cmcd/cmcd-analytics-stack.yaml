AWSTemplateFormatVersion: '2010-09-09'
Description: 'CMCD Analytics Platform - Captures, processes, and analyzes streaming media performance data using CloudFront, Kinesis, Lambda, and Timestream for InfluxDB'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "General Configuration"
        Parameters:
          - ProjectName
          - Environment
      - Label:
          default: "InfluxDB Configuration"
        Parameters:
          - InfluxDBInstanceType
          - InfluxDBStorageSize
          - InfluxDBOrganization
          - InfluxDBBucketName
          - InfluxDBUsername
      - Label:
          default: "Network Configuration"
        Parameters:
          - VpcCIDR
          - PublicSubnet1CIDR
          - PublicSubnet2CIDR
          - PrivateSubnet1CIDR
          - PrivateSubnet2CIDR
      - Label:
          default: "Bastion Host Configuration"
        Parameters:
          - BastionInstanceType
          - SSMSessionManagerAccess

Parameters:
  ProjectName:
    Type: String
    Default: cmcd-analytics
    Description: Name for this project (used in resource naming)
    AllowedPattern: ^[a-zA-Z0-9-]*$
    ConstraintDescription: Project name can include letters, numbers, and hyphens

  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - test
      - prod
    Description: Deployment environment

  LatestAmazonLinuxAMI:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64
    Description: Latest Amazon Linux 2023 AMI from SSM Parameter Store

  InfluxDBInstanceType:
    Type: String
    Default: db.influx.medium
    AllowedValues:
      - db.influx.medium
      - db.influx.large
      - db.influx.xlarge
      - db.influx.2xlarge
      - db.influx.4xlarge
    Description: The instance type for Timestream InfluxDB

  InfluxDBStorageSize:
    Type: Number
    Default: 20
    MinValue: 20
    MaxValue: 16384
    Description: Storage size in GiB for InfluxDB (min 20, max 16384)

  InfluxDBOrganization:
    Type: String
    Default: cmcd-org
    Description: Name of the InfluxDB organization
    MinLength: 1
    MaxLength: 64

  InfluxDBBucketName:
    Type: String
    Default: cmcd-metrics
    Description: Name of the InfluxDB bucket
    MinLength: 2
    MaxLength: 64
    AllowedPattern: ^[^_][^"]*$
    ConstraintDescription: Bucket name cannot start with underscore or contain double quotes

  InfluxDBUsername:
    Type: String
    Default: admin
    Description: Username for InfluxDB admin user
    MinLength: 1
    MaxLength: 64
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9]*$
    ConstraintDescription: Username must start with a letter and contain only alphanumeric characters

  VpcCIDR:
    Type: String
    Default: 10.0.0.0/16
    Description: CIDR block for the VPC
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: CIDR block must be in the format x.x.x.x/16-28

  PublicSubnet1CIDR:
    Type: String
    Default: 10.0.0.0/24
    Description: CIDR block for public subnet 1
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: CIDR block must be in the format x.x.x.x/16-28

  PublicSubnet2CIDR:
    Type: String
    Default: 10.0.1.0/24
    Description: CIDR block for public subnet 2
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: CIDR block must be in the format x.x.x.x/16-28

  PrivateSubnet1CIDR:
    Type: String
    Default: 10.0.2.0/24
    Description: CIDR block for private subnet 1
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: CIDR block must be in the format x.x.x.x/16-28

  PrivateSubnet2CIDR:
    Type: String
    Default: 10.0.3.0/24
    Description: CIDR block for private subnet 2
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: CIDR block must be in the format x.x.x.x/16-28

  BastionInstanceType:
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
    Description: Instance type for the bastion host

  SSMSessionManagerAccess:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: Enable SSM Session Manager access to the bastion host

Resources:
  # VPC and Network Resources
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-vpc

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-igw

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !Ref PublicSubnet1CIDR
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-public-subnet-1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !Ref PublicSubnet2CIDR
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-public-subnet-2

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !Ref PrivateSubnet1CIDR
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-private-subnet-1

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !Ref PrivateSubnet2CIDR
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-private-subnet-2

  NatGatewayEIP:
    Type: AWS::EC2::EIP
    DependsOn: InternetGatewayAttachment
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-nat-eip

  NatGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-nat-gateway

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-public-routes

  DefaultPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-private-routes

  DefaultPrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      SubnetId: !Ref PrivateSubnet1

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      SubnetId: !Ref PrivateSubnet2

  # S3 Bucket for Content
  ContentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${ProjectName}-content-${AWS::AccountId}-${AWS::Region}
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-content-bucket

  # Create videos folder in S3 bucket
  VideosFolderCreation:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: ContentBucket
    Properties:
      ServiceToken: !GetAtt CreateVideosFolderFunction.Arn
      BucketName: !Ref ContentBucket

  # Lambda function to create videos folder
  CreateVideosFolderFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt VideosFolderCreationRole.Arn
      Runtime: python3.11
      Timeout: 30
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      s3 = boto3.client('s3')
                      
                      # Get parameters
                      bucket_name = event['ResourceProperties']['BucketName']
                      
                      # Create an empty object with the videos/ key
                      s3.put_object(
                          Bucket=bucket_name,
                          Key='videos/',
                          Body=''
                      )
                      
                      # Create a simple response
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': f'Successfully created videos folder in {bucket_name}'
                      })
                  elif event['RequestType'] == 'Delete':
                      # Nothing to do for delete
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': 'Delete request processed'
                      })
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

  # IAM role for the videos folder creation Lambda
  VideosFolderCreationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub ${ContentBucket.Arn}/*

  ContentBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ContentBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub ${ContentBucket.Arn}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}

  # CloudFront Distribution
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub ${ProjectName}-${Environment}-oac
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub ${ProjectName}-${Environment}-distribution
        DefaultRootObject: index.html
        Origins:
          - Id: s3-origin
            DomainName: !GetAtt ContentBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !Ref CloudFrontOriginAccessControl
        DefaultCacheBehavior:
          TargetOriginId: s3-origin
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # CORS-S3Origin
          ResponseHeadersPolicyId: 5cc3b908-e619-4b99-88e5-2cf7f45965bd  # CORS-With-Preflight
          RealtimeLogConfigArn: !GetAtt CMCDRealtimeLogConfig.Arn
        PriceClass: PriceClass_100
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-cloudfront

  # Kinesis Data Stream
  CMCDKinesisStream:
    Type: AWS::Kinesis::Stream
    Properties:
      Name: !Sub ${ProjectName}-${Environment}-stream
      ShardCount: 1
      RetentionPeriodHours: 24
      StreamModeDetails:
        StreamMode: PROVISIONED
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-kinesis-stream

  # CloudFront Real-time Logs
  CloudFrontLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: KinesisWritePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - kinesis:PutRecord
                  - kinesis:PutRecords
                Resource: !GetAtt CMCDKinesisStream.Arn
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-cloudfront-logs-role

  CMCDRealtimeLogConfig:
    Type: AWS::CloudFront::RealtimeLogConfig
    Properties:
      Name: !Sub ${ProjectName}-${Environment}-realtime-logs
      EndPoints:
        - StreamType: Kinesis
          KinesisStreamConfig:
            RoleArn: !GetAtt CloudFrontLogsRole.Arn
            StreamArn: !GetAtt CMCDKinesisStream.Arn
      Fields:
        - timestamp
        - c-ip
        - sc-status
        - cs-method
        - cs-uri-stem
        - cs-uri-query
        - cs-headers
        - time-taken
        - x-edge-location
        - x-edge-request-id
      SamplingRate: 100

  # Security Groups
  InfluxDBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for InfluxDB instance
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-influxdb-sg

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda function
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-lambda-sg

  BastionSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Bastion Host
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8765
          ToPort: 8765
          CidrIp: 0.0.0.0/0
          Description: Allow WebSocket connections to MCP server
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: Allow SSH access (for troubleshooting)
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8086
          ToPort: 8086
          DestinationSecurityGroupId: !Ref InfluxDBSecurityGroup
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-bastion-sg

  # Security Group Rules
  LambdaToInfluxDBRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref InfluxDBSecurityGroup
      IpProtocol: tcp
      FromPort: 8086
      ToPort: 8086
      SourceSecurityGroupId: !Ref LambdaSecurityGroup

  BastionToInfluxDBIngressRule:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref InfluxDBSecurityGroup
      IpProtocol: tcp
      FromPort: 8086
      ToPort: 8086
      SourceSecurityGroupId: !Ref BastionSecurityGroup

  # InfluxDB Password Secret
  InfluxDBSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: !Sub ${ProjectName}-${Environment}-influxdb-credentials
      GenerateSecretString:
        SecretStringTemplate: !Sub '{"username": "${InfluxDBUsername}"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludePunctuation: true
        ExcludeCharacters: '"@/\\`'
        IncludeSpace: false
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-influxdb-secret

  # Timestream for InfluxDB
  InfluxDBInstance:
    Type: AWS::Timestream::InfluxDBInstance
    Properties:
      Name: !Sub ${ProjectName}-${Environment}-influxdb
      DbInstanceType: !Ref InfluxDBInstanceType
      AllocatedStorage: !Ref InfluxDBStorageSize
      DbStorageType: InfluxIOIncludedT1
      DeploymentType: SINGLE_AZ
      Bucket: !Ref InfluxDBBucketName
      Organization: !Ref InfluxDBOrganization
      Username: !Ref InfluxDBUsername
      Password: !Sub '{{resolve:secretsmanager:${InfluxDBSecret}:SecretString:password}}'
      VpcSubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcSecurityGroupIds:
        - !Ref InfluxDBSecurityGroup
      PubliclyAccessible: false
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-influxdb

  # IAM Role for Bastion Host
  BastionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/AmazonSSMFullAccess
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      Policies:
        - PolicyName: InfluxDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref InfluxDBSecret
        - PolicyName: SSMSessionManagerPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:UpdateInstanceInformation
                  - ssm:ListInstanceAssociations
                  - ssm:DescribeInstanceProperties
                  - ssm:DescribeDocumentParameters
                  - ssmmessages:CreateControlChannel
                  - ssmmessages:CreateDataChannel
                  - ssmmessages:OpenControlChannel
                  - ssmmessages:OpenDataChannel
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-bastion-role

  # Instance Profile for Bastion Host
  BastionInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref BastionRole

  # Bastion Host EC2 Instance
  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmazonLinuxAMI
      InstanceType: !Ref BastionInstanceType
      SubnetId: !Ref PublicSubnet1
      SecurityGroupIds:
        - !Ref BastionSecurityGroup
      IamInstanceProfile: !Ref BastionInstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Update system packages
          yum update -y
          yum install -y amazon-ssm-agent curl jq python3 python3-pip git screen
          
          # Fix shell permissions for SSM
          chmod 755 /usr/bin/sh
          chmod 755 /bin/bash
          chmod 755 /bin/sh
          
          # Fix SSM agent permissions
          systemctl stop amazon-ssm-agent
          mkdir -p /etc/amazon/ssm
          mkdir -p /var/lib/amazon/ssm
          chmod -R 755 /etc/amazon/ssm
          chmod -R 755 /var/lib/amazon/ssm
          
          # Configure PAM limits for ssm-user
          echo 'session required pam_limits.so' >> /etc/pam.d/common-session
          echo 'ssm-user soft nofile 65535' >> /etc/security/limits.conf
          echo 'ssm-user hard nofile 65535' >> /etc/security/limits.conf
          
          # Start and enable SSM agent
          systemctl enable amazon-ssm-agent
          systemctl start amazon-ssm-agent
          
          # Create ssm-user if it doesn't exist
          if ! id -u ssm-user > /dev/null 2>&1; then
            useradd -m ssm-user
            echo 'ssm-user ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/ssm-user
            chmod 440 /etc/sudoers.d/ssm-user
          fi
          
          # Install InfluxDB CLI
          curl -LO https://dl.influxdata.com/influxdb/releases/influxdb2-client-2.7.3-linux-amd64.tar.gz
          tar xvzf influxdb2-client-2.7.3-linux-amd64.tar.gz
          cp influx /usr/local/bin/
          
          # Create project directory
          mkdir -p /home/ec2-user/cmcd/mcp
          chown -R ec2-user:ec2-user /home/ec2-user/cmcd
          
          # Install Python dependencies
          pip3 install boto3 influxdb-client python-dotenv loguru mcp-server-fastmcp
          
          # Create connection script
          cat > /home/ec2-user/connect-influxdb.sh << 'EOF'
          #!/bin/bash
          SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id ${InfluxDBSecret} --query SecretString --output text --region ${AWS::Region})
          PASSWORD=$(echo $SECRET_VALUE | jq -r .password)
          INFLUXDB_ENDPOINT="${InfluxDBInstance.Endpoint}"
          
          echo "InfluxDB Endpoint: $INFLUXDB_ENDPOINT"
          echo "Username: ${InfluxDBUsername}"
          echo "Password: $PASSWORD"
          echo ""
          echo "To connect using InfluxDB CLI:"
          echo "influx -host $INFLUXDB_ENDPOINT -username ${InfluxDBUsername} -password $PASSWORD"
          
          # Create .env file for MCP server
          cat > /home/ec2-user/cmcd/mcp/.env << EOL
          INFLUXDB_URL=https://$INFLUXDB_ENDPOINT:8086
          INFLUXDB_TOKEN=$PASSWORD
          INFLUXDB_ORG=${InfluxDBOrganization}
          VERIFY_SSL=False
          EOL
          
          echo ""
          echo ".env file created at /home/ec2-user/cmcd/mcp/.env"
          EOF
          
          chmod +x /home/ec2-user/connect-influxdb.sh
          chown ec2-user:ec2-user /home/ec2-user/connect-influxdb.sh
          
          # Create MCP configuration file
          cat > /home/ec2-user/cmcd/mcp/mcp.json << 'EOF'
          {
            "mcpServers": {
              "cmcd-mcp": {
                "command": "python3",
                "args": [
                  "cmcd_server.py"
                ],
                "cwd": "/home/ec2-user/cmcd/mcp",
                "env": {
                  "FASTMCP_LOG_LEVEL": "INFO"
                }
              }
            }
          }
          EOF
          
          chown ec2-user:ec2-user /home/ec2-user/cmcd/mcp/mcp.json
          
          # Create start script for standard MCP server
          cat > /home/ec2-user/start-mcp-server.sh << 'EOF'
          #!/bin/bash
          cd /home/ec2-user/cmcd/mcp
          pip3 install -r requirements.txt
          screen -dmS mcp_server bash -c "python3 cmcd_server.py; exec bash"
          echo "MCP server started in a screen session."
          echo "To attach to it, run: screen -r mcp_server"
          echo "To detach from the screen session (leaving the server running), press Ctrl+A followed by D."
          EOF
          
          # Create start script for WebSocket MCP server
          cat > /home/ec2-user/start-websocket-mcp-server.sh << 'EOF'
          #!/bin/bash
          cd /home/ec2-user/cmcd/mcp
          pip3 install -r requirements.txt websockets
          screen -dmS mcp_websocket bash -c "python3 -m mcp.server.websocket_server --host 0.0.0.0 --port 8765 cmcd_server.py; exec bash"
          echo "MCP WebSocket server started in a screen session on port 8765."
          echo "To attach to it, run: screen -r mcp_websocket"
          echo "To detach from the screen session (leaving the server running), press Ctrl+A followed by D."
          echo ""
          echo "To connect from your local machine, use:"
          echo "1. Set up port forwarding: aws ssm start-session --target INSTANCE_ID --document-name AWS-StartPortForwardingSession --parameters 'portNumber=[8765],localPortNumber=[8765]'"
          echo "2. Create a WebSocket client that connects to ws://localhost:8765"
          EOF
          
          chmod +x /home/ec2-user/start-mcp-server.sh
          chmod +x /home/ec2-user/start-websocket-mcp-server.sh
          chown ec2-user:ec2-user /home/ec2-user/start-mcp-server.sh
          chown ec2-user:ec2-user /home/ec2-user/start-websocket-mcp-server.sh
          
          # Create a sample WebSocket client script
          mkdir -p /home/ec2-user/cmcd-client
          cat > /home/ec2-user/cmcd-client/websocket_client.py << 'EOF'
          import asyncio
          import json
          from mcp import ClientSession
          from mcp.client.websocket import websocket_client
          
          async def main():
              # Connect to the MCP server via WebSocket
              # Replace localhost with the actual hostname if running remotely
              async with websocket_client("ws://localhost:8765") as session:
                  # List available tools
                  tools = await session.list_tools()
                  print("Available tools:")
                  for tool in tools:
                      print(f"- {tool.name}: {tool.description}")
                  
                  # Get average bitrate
                  result = await session.call_tool("get_average_bitrate", {
                      "time_range": "-1h"
                  })
                  print("\nAverage Bitrate Result:")
                  print(result.content)
          
          if __name__ == "__main__":
              asyncio.run(main())
          EOF
          
          chown ec2-user:ec2-user -R /home/ec2-user/cmcd-client
          
          # Install required Python packages
          pip3 install mcp-client websockets
          
          # Create a troubleshooting script
          cat > /home/ec2-user/fix-ssm.sh << 'EOF'
          #!/bin/bash
          # Script to fix SSM issues
          
          echo "Fixing SSM permissions..."
          sudo chmod 755 /usr/bin/sh
          sudo chmod 755 /bin/bash
          sudo chmod 755 /bin/sh
          
          echo "Restarting SSM agent..."
          sudo systemctl restart amazon-ssm-agent
          
          echo "Checking SSM agent status..."
          sudo systemctl status amazon-ssm-agent
          
          echo "Checking SSM logs..."
          sudo tail -n 20 /var/log/amazon/ssm/amazon-ssm-agent.log
          
          echo "Done. If you're still having issues, try rebooting the instance."
          EOF
          
          chmod +x /home/ec2-user/fix-ssm.sh
          chown ec2-user:ec2-user /home/ec2-user/fix-ssm.sh
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-bastion

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaKinesisExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: InfluxDBAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - timestream:GetInfluxDBInstance
                  - secretsmanager:GetSecretValue
                Resource: 
                  - !Sub 'arn:aws:timestream:${AWS::Region}:${AWS::AccountId}:influxdb-instance/${InfluxDBInstance}'
                  - !Ref InfluxDBSecret
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-lambda-role

  # Lambda Function
  CMCDProcessorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${ProjectName}-${Environment}-processor
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 60
      MemorySize: 256
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
      Code:
        ZipFile: |
          import json
          import base64
          import boto3
          import os
          import urllib.parse
          import logging
          import urllib3

          # Configure logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          http = urllib3.PoolManager()

          def lambda_handler(event, context):
              try:
                  logger.info(f"Processing {len(event['Records'])} records")
                  
                  # Get InfluxDB endpoint and token
                  endpoint = os.environ['INFLUXDB_ENDPOINT']
                  token = os.environ['INFLUXDB_TOKEN']
                  
                  logger.info(f"Connecting to InfluxDB at {endpoint}")
                  
                  processed_count = 0
                  error_count = 0
                  
                  for record in event['Records']:
                      try:
                          # Decode the base64 data from Kinesis
                          payload = base64.b64decode(record['kinesis']['data']).decode('utf-8')
                          log_data = parse_cloudfront_log(payload)
                          
                          if log_data:
                              write_to_influxdb(endpoint, token, log_data)
                              processed_count += 1
                              logger.debug(f"Processed record with CMCD data: {log_data.get('cmcd_data', {})}")
                          else:
                              logger.debug("Failed to parse CloudFront log record")
                              
                      except Exception as e:
                          error_count += 1
                          logger.error(f"Error processing record: {str(e)}")
                  
                  logger.info(f"Successfully processed {processed_count} records, {error_count} errors")
                  return {'statusCode': 200, 'body': f'Processed {processed_count} records, {error_count} errors'}
                  
              except Exception as e:
                  logger.error(f"Lambda execution error: {str(e)}")
                  raise

          def parse_cloudfront_log(log_line):
              try:
                  fields = log_line.strip().split('\t')
                  if len(fields) < 9:
                      logger.warning(f"Insufficient fields in log line: {len(fields)}")
                      return None
                      
                  # Extract CMCD from URI (field 4) and query string (field 8)
                  uri = fields[4] if len(fields) > 4 else ''
                  query_string = fields[8] if len(fields) > 8 else ''
                  
                  cmcd_data = {}
                  # Parse CMCD from URI query parameters
                  if 'CMCD=' in uri:
                      cmcd_data.update(extract_cmcd_from_query(uri))
                  # Parse CMCD from separate query string field
                  if 'CMCD=' in query_string:
                      cmcd_data.update(extract_cmcd_from_query(query_string))
                  
                  return {
                      'timestamp': int(float(fields[0]) * 1000000000),
                      'client_ip': fields[1],
                      'status': fields[2],
                      'method': fields[3],
                      'uri': uri,
                      'edge_location': fields[5],
                      'time_taken': float(fields[7]) if len(fields) > 7 and fields[7].replace('.', '').isdigit() else 0,
                      'cmcd_data': cmcd_data
                  }
              except Exception as e:
                  logger.error(f"Error parsing CloudFront log: {str(e)}")
                  return None

          def extract_cmcd_from_query(query_str):
              cmcd_data = {}
              try:
                  # Find CMCD parameter in the query string
                  if 'CMCD=' in query_str:
                      # Extract the CMCD value (URL encoded)
                      cmcd_start = query_str.find('CMCD=') + 5
                      cmcd_end = query_str.find('&', cmcd_start)
                      if cmcd_end == -1:
                          cmcd_end = len(query_str)
                      
                      cmcd_value = query_str[cmcd_start:cmcd_end]
                      # URL decode the CMCD value multiple times if needed (double/triple encoded)
                      decoded_cmcd = cmcd_value
                      for _ in range(3):  # Try up to 3 levels of decoding
                          try:
                              new_decoded = urllib.parse.unquote(decoded_cmcd)
                              if new_decoded == decoded_cmcd:
                                  break  # No more decoding needed
                              decoded_cmcd = new_decoded
                          except:
                              break
                      
                      # Parse CMCD key-value pairs
                      cmcd_data = parse_cmcd_value(decoded_cmcd)
                      
              except Exception as e:
                  logger.error(f"Error extracting CMCD from query: {str(e)}")
              return cmcd_data

          def parse_cmcd_value(value):
              parsed = {}
              try:
                  # CMCD format: key1=value1,key2=value2,key3=value3
                  for pair in value.split(','):
                      if '=' in pair:
                          k, v = pair.split('=', 1)
                          # Remove quotes and clean up the value
                          parsed[k.strip()] = v.strip().strip('"')
                      else:
                          # Handle boolean flags (keys without values)
                          parsed[pair.strip()] = True
              except Exception as e:
                  logger.error(f"Error parsing CMCD value: {str(e)}")
              return parsed

          def write_to_influxdb(endpoint, token, log_data):
              try:
                  # Create Telegraf-style line protocol
                  tags = []
                  fields = []
                  
                  # Add basic tags (escape special characters)
                  tags.append(f"client_ip={log_data['client_ip']}")
                  tags.append(f"edge_location={log_data['edge_location']}")
                  tags.append(f"status={log_data['status']}")
                  tags.append(f"method={log_data['method']}")
                  
                  # Add basic fields
                  fields.append(f"time_taken={log_data['time_taken']}")
                  
                  # Add CMCD fields if they exist
                  if log_data.get('cmcd_data'):
                      for key, value in log_data['cmcd_data'].items():
                          # Escape key names and values for InfluxDB line protocol
                          safe_key = key.replace(' ', '_').replace(',', '_').replace('=', '_')
                          
                          if isinstance(value, bool):
                              fields.append(f"cmcd_{safe_key}={str(value).lower()}")
                          elif isinstance(value, str) and value.isdigit():
                              fields.append(f"cmcd_{safe_key}={value}")
                          elif isinstance(value, (int, float)):
                              fields.append(f"cmcd_{safe_key}={value}")
                          elif isinstance(value, str):
                              # Escape string values for tags
                              safe_value = value.replace(',', '\\,').replace('=', '\\=').replace(' ', '\\ ')
                              tags.append(f"cmcd_{safe_key}={safe_value}")
                          else:
                              fields.append(f"cmcd_{safe_key}={value}")
                  
                  # Ensure we have at least one field
                  if not fields:
                      fields.append("processed=1")
                  
                  line_protocol = f"cloudfront_logs,{','.join(tags)} {','.join(fields)} {log_data['timestamp']}"
                  
                  logger.debug(f"Line protocol: {line_protocol}")
                  
                  # Write to InfluxDB using v2 API with token
                  url = f"{endpoint}/api/v2/write"
                  headers = {
                      'Authorization': f"Token {token}",
                      'Content-Type': 'text/plain'
                  }
                  
                  params = f"org={os.environ['INFLUXDB_ORG']}&bucket={os.environ['INFLUXDB_BUCKET']}"
                  full_url = f"{url}?{params}"
                  
                  response = http.request('POST', full_url, headers=headers, body=line_protocol)
                  
                  if response.status == 204:
                      logger.info("Successfully wrote point to InfluxDB")
                  else:
                      logger.error(f"InfluxDB write failed: {response.status} - {response.data}")
                      raise Exception(f"InfluxDB write failed: {response.status}")
                      
              except Exception as e:
                  logger.error(f"Error writing to InfluxDB: {str(e)}")
                  raise
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          INFLUXDB_ENDPOINT: !Sub 'https://${InfluxDBInstance.Endpoint}:8086'
          INFLUXDB_ORG: !Ref InfluxDBOrganization
          INFLUXDB_BUCKET: !Ref InfluxDBBucketName
          INFLUXDB_TOKEN: !Sub '{{resolve:secretsmanager:${InfluxDBSecret}:SecretString:password}}'
      Tags:
        - Key: Name
          Value: !Sub ${ProjectName}-${Environment}-lambda

  # Event Source Mapping
  KinesisEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt CMCDKinesisStream.Arn
      FunctionName: !Ref CMCDProcessorLambda
      StartingPosition: LATEST
      BatchSize: 100

  # Upload index.html to S3 bucket
  IndexHtmlDeployment:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: ContentBucket
    Properties:
      ServiceToken: !GetAtt IndexHtmlDeploymentFunction.Arn
      CloudFrontDomain: !GetAtt CloudFrontDistribution.DomainName
      BucketName: !Ref ContentBucket

  # Lambda function to deploy index.html
  IndexHtmlDeploymentFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt IndexHtmlDeploymentRole.Arn
      Runtime: python3.11
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      s3 = boto3.client('s3')
                      
                      # Get parameters
                      bucket_name = event['ResourceProperties']['BucketName']
                      cloudfront_domain = event['ResourceProperties']['CloudFrontDomain']
                      
                      # Create index.html content with CloudFront domain
                      index_html = f"""<!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>HLS Video Player</title>
              <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
              <style>
                  body {{
                      font-family: Arial, sans-serif;
                      max-width: 800px;
                      margin: 0 auto;
                      padding: 20px;
                      background-color: #f5f5f5;
                  }}
                  .video-container {{
                      background: white;
                      padding: 20px;
                      border-radius: 8px;
                      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                  }}
                  video {{
                      width: 100%;
                      height: auto;
                      border-radius: 4px;
                  }}
                  h1 {{
                      color: #333;
                      text-align: center;
                  }}
              </style>
          </head>
          <body>
              <h1>HLS Video Player</h1>
              <div class="video-container">
                  <video id="video" controls></video>
              </div>
              <script>
                  const video = document.getElementById('video');
                  const sessionId = 'session_' + Date.now().toString(36) + Math.random().toString(36).substring(2);
                  
                  if (Hls.isSupported()) {{
                      const hls = new Hls({{
                          cmcd: {{
                              sessionId: sessionId,
                              contentId: 'video-content-demo'
                          }}
                      }});
                      hls.loadSource('https://{cloudfront_domain}/videos/master.m3u8');
                      hls.attachMedia(video);
                  }} else if (video.canPlayType('application/vnd.apple.mpegurl')) {{
                      // Native HLS support (Safari)
                      video.src = 'https://{cloudfront_domain}/videos/master.m3u8';
                  }}
              </script>
          </body>
          </html>
          """
                      
                      # Upload index.html to S3
                      s3.put_object(
                          Bucket=bucket_name,
                          Key='index.html',
                          Body=index_html,
                          ContentType='text/html'
                      )
                      
                      # Create a simple response
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': f'Successfully deployed index.html to {bucket_name}'
                      })
                  elif event['RequestType'] == 'Delete':
                      # Nothing to do for delete
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': 'Delete request processed'
                      })
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

  # IAM role for the custom resource Lambda
  IndexHtmlDeploymentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub ${ContentBucket.Arn}/*

Outputs:
  CloudFrontDistributionId:
    Description: CloudFront Distribution ID
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub ${ProjectName}-${Environment}-CloudFrontDistributionId
  
  CloudFrontDomainName:
    Description: CloudFront Distribution Domain Name
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub ${ProjectName}-${Environment}-CloudFrontDomainName

  KinesisStreamArn:
    Description: Kinesis Data Stream ARN
    Value: !GetAtt CMCDKinesisStream.Arn
    Export:
      Name: !Sub ${ProjectName}-${Environment}-KinesisStreamArn

  LambdaFunctionArn:
    Description: Lambda Function ARN
    Value: !GetAtt CMCDProcessorLambda.Arn
    Export:
      Name: !Sub ${ProjectName}-${Environment}-LambdaFunctionArn
  
  InfluxDBInstanceId:
    Description: InfluxDB Instance ID
    Value: !Ref InfluxDBInstance
    Export:
      Name: !Sub ${ProjectName}-${Environment}-InfluxDBInstanceId

  InfluxDBEndpoint:
    Description: InfluxDB Endpoint
    Value: !GetAtt InfluxDBInstance.Endpoint
    Export:
      Name: !Sub ${ProjectName}-${Environment}-InfluxDBEndpoint

  S3BucketName:
    Description: S3 Bucket Name
    Value: !Ref ContentBucket
    Export:
      Name: !Sub ${ProjectName}-${Environment}-S3BucketName

  BastionHostInstanceId:
    Description: Instance ID of the Bastion Host
    Value: !Ref BastionHost
    Export:
      Name: !Sub ${ProjectName}-${Environment}-BastionHostInstanceId
  
  SessionManagerCommand:
    Description: Command to connect to bastion host via Session Manager
    Value: !Sub 'aws ssm start-session --target ${BastionHost} --region ${AWS::Region}'
    Export:
      Name: !Sub ${ProjectName}-${Environment}-SessionManagerCommand
  
  InfluxDBConnectionScript:
    Description: Script location on bastion host to get InfluxDB connection details
    Value: '/home/ec2-user/connect-influxdb.sh'
    Export:
      Name: !Sub ${ProjectName}-${Environment}-InfluxDBConnectionScript